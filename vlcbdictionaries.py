# DO NOT EDIT THIS FILE.
# This file is automatically generated by generateVlcbLookup.sh from vlcb-defs.csv
#

# 		Copyright (C) Sven Rosvall (sven@rosvall.ie)
# 		This file is part of VLCB-Arduino project on https://github.com/SvenRosvall/VLCB-Arduino
# 		Licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
# 		The full licence can be found at: http://creativecommons.org/licenses/by-nc-sa/4.0/
VlcbManufacturer = {
  # Manufacturer definitions
  # Where the manufacturer already has an NMRA code, this is used
  # 
  13 : "DEV", # For new manufacturer development - who don't have a manufacturer id yet
  165 : "MERG", # https://www.merg.co.uk
  44 : "SPROG", # https://www.sprog-dcc.co.uk/
  70 : "ROCRAIL", # http://www.rocrail.net
  80 : "SPECTRUM", # http://animatedmodeler.com  (Spectrum Engineering)
  250 : "MERG_VLCB", # range of MERG VLCB modules
  250 : "VLCB", # range of MERG VLCB modules (Deprecated in favour of MANU_MERG_VLCB)
  249 : "SYSPIXIE", # Konrad Orlowski
  248 : "RME", # http://rmeuk.com  (Railway Modelling Experts Limited)
}

VlcbMergModuleTypes = {
  # 
  # MODULE TYPES
  # 
  # Please note that the existence of a module type id does not necessarily mean that firmware has been implemented
  # 
  # MERG Module types
  # 
  0 : "SLIM", # default for SLiM nodes
  1 : "CANACC4", # Solenoid point driver
  2 : "CANACC5", # Motorised point driver
  3 : "CANACC8", # 8 digital outputs
  4 : "CANACE3", # Control panel switch/button encoder
  5 : "CANACE8C", # 8 digital inputs
  6 : "CANLED", # 64 led driver
  7 : "CANLED64", # 64 led driver (multi leds per event)
  8 : "CANACC4_2", # 12v version of CANACC4
  9 : "CANCAB", # CANCAB hand throttle
  10 : "CANCMD", # CANCMD command station
  11 : "CANSERVO", # 8 servo driver (on canacc8 or similar hardware)
  12 : "CANBC", # BC1a command station
  13 : "CANRPI", # RPI and RFID interface
  14 : "CANTTCA", # Turntable controller (turntable end)
  15 : "CANTTCB", # Turntable controller (control panel end)
  16 : "CANHS", # Handset controller for old BC1a type handsets
  17 : "CANTOTI", # Track occupancy detector
  18 : "CAN8I8O", # 8 inputs 8 outputs
  19 : "CANSERVO8C", # Canservo with servo position feedback
  20 : "CANRFID", # RFID input
  21 : "CANTC4",
  22 : "CANACE16C", # 16 inputs
  23 : "CANIO8", # 8 way I/O
  24 : "CANSNDX", # ??
  25 : "CANEther", # Ethernet interface
  26 : "CANSIG64", # Multiple aspect signalling for CANLED module
  27 : "CANSIG8", # Multiple aspect signalling for CANACC8 module
  28 : "CANCOND8C", # Conditional event generation
  29 : "CANPAN", # Control panel 32/32
  30 : "CANACE3C", # Newer version of CANACE3 firmware
  31 : "CANPanel", # Control panel 64/64
  32 : "CANMIO", # Multiple I/O â€“ Universal CANMIO firmware
  33 : "CANACE8MIO", # Multiple IO module 16 inputs emulating CANACE8C on CANMIO hardware
  34 : "CANSOL", # Solenoid driver module
  35 : "CANBIP", # Universal CANBIP firmware - Bipolar IO module with additional 8 I/O pins (CANMIO family)
  36 : "CANCDU", # Solenoid driver module with additional 6 I/O pins (CANMIO family)
  37 : "CANACC4CDU", # CANACC4 firmware ported to CANCDU
  38 : "CANWiBase", # CAN to MiWi base station
  39 : "WiCAB", # Wireless cab using MiWi protocol
  40 : "CANWiFi", # CAN to WiFi connection with Withrottle to CBUS protocol conversion
  41 : "CANFTT", # Turntable controller configured using FLiM
  42 : "CANHNDST", # Handset (alternative to CANCAB)
  43 : "CANTCHNDST", # Touchscreen handset
  44 : "CANRFID8", # multi-channel RFID reader
  45 : "CANmchRFID", # either a 2ch or 8ch RFID reader
  46 : "CANPiWi", # a Raspberry Pi based module for WiFi
  47 : "CAN4DC", # DC train controller
  48 : "CANELEV", # Nelevator controller
  49 : "CANSCAN", # 128 switch inputs
  50 : "CANMIO_SVO", # 16MHz 25k80 version of CANSERVO8c on CANMIO hardware
  51 : "CANMIO_INP", # 16MHz 25k80 version of CANACE8MIO on CANMIO hardware
  52 : "CANMIO_OUT", # 16MHz 25k80 version of CANACC8 on CANMIO hardware
  53 : "CANBIP_OUT", # 16MHz 25k80 version of CANACC5 on CANBIP hardware
  54 : "CANASTOP", # DCC stop generator
  55 : "CANCSB", # CANCMD with on board 3A booster
  56 : "CANMAG", # Magnet on Track detector
  57 : "CANACE16CMIO", # 16 input equivaent to CANACE8C
  58 : "CANPiNODE", # CBUS module based on Raspberry Pi
  59 : "CANDISP", # 25K80 version of CANLED64 (IHart and MB)
  60 : "CANCOMPUTE", # Compute Event processing engine
  61 : "CANRC522", # Read/Write from/to RC522 RFID tags
  62 : "CANINP", # 8 inputs module (2g version of CANACE8c) (Pete Brownlow)
  63 : "CANOUT", # 8 outputs module (2g version of CANACC8) (Pete Brownlow)
  64 : "CANXIO", # Extended CANMIO (24 I/O ports) (Pete Brownlow)
  65 : "CANCABDC", # DC cab
  66 : "CANRCOM", # DC Railcom detector/reader
  67 : "CANMP3", # MP3 sound player in response to events (eg: station announcements) (Duncan Greenwood)
  68 : "CANXMAS", # Addressed RGB LED driver (Duncan Greenwood)
  69 : "CANSVOSET", # Servo setting box (Duncan Greenwood)
  70 : "CANCMDDC", # DC Command station
  71 : "CANTEXT", # Text message display
  72 : "CANASIGNAL", # Signal controller
  73 : "CANSLIDER", # DCC cab with slider control (Dave Radcliffe)
  74 : "CANDCATC", # DC ATC module (Dave Harris)
  75 : "CANGATE", # Logic module using and/or gates (Phil Silver)
  76 : "CANSINP", # Q series PIC input module (Ian Hart)
  77 : "CANSOUT", # Q series PIC input module (Ian Hart)
  78 : "CANSBIP", # Q series PIC input module (Ian Hart)
  79 : "CANBUFFER", # Message buffer (Phil Silver)
  80 : "CANLEVER", # Lever frame module (Tim Coombs)
  81 : "CANSHIELD", # Kit 110 Arduino shield test firmware
  82 : "CAN4IN4OUT", # 4 inputs 4 outputs (Arduino module)
  83 : "CANCMDB", # CANCMD with built in booster (Simon West)
  84 : "CANPIXEL", # neopixel driver (Jon Denham)
  85 : "CANCABPE", # Cab2 with pot or encoder (Simon West hardware, Jon Denham new C firmware)
  86 : "CANSMARTTD", # Smart train detector (Michael Smith)
  0xFC : "VLCB", # All VLCB modules have the same ID
  # 
  # At the time of writing the list of defined MERG module types is maintained by Pete Brownlow software@upsys.co.uk
  # Please liaise with Pete before adding new module types, 
  # and/or create your own GitHub branch, add your proposed new module type(s) and then create a Pull Request
  # 
  0xFF : "CAN_SW", # Software nodes
  0xFE : "EMPTY", # Empty module, bootloader only
  0xFD : "CANUSB", # USB interface
  0xFC : "CANDEV", # Module type for use by developers when developing something new
}

VlcbSprogModuleTypes = {
  # 
  # Sprog Module types
  # 
  1 : "CANPiSPRG3", # Pi-SPROG 3 programmer/command station
  2 : "CANSPROG3P", # SPROG 3 Plus programmer/command station
  3 : "CANSPROG", # CAN SPROG programmer/command station
  4 : "CANSBOOST", # System Booster
  5 : "CANPiSPRGP", # Pi-SPROG 3 Plus programmer/command station
  8 : "CANSOLNOID ", # 8-channel (4-pairs) Solenoid I/O module
  50 : "CANSERVOIO", # 8-channel Servo I/O module
  100 : "CANISB", # CAN ISB Isolated CAN USB Interface
  101 : "CANSOLIO ", # 8-channel (4-pairs) Solenoid I/O module
}

VlcbRocRailModuleTypes = {
  # 
  # Rocrail Module types
  # 
  1 : "CANGC1", # RS232 PC interface
  2 : "CANGC2", # 16 I/O
  3 : "CANGC3", # Command station (derived from cancmd)
  4 : "CANGC4", # 8 channel RFID reader
  5 : "CANGC5", # Cab for fixed panels (derived from cancab)
  6 : "CANGC6", # 4 channel servo controller
  7 : "CANGC7", # Fast clock module
  11 : "CANGC1e", # CAN<->Ethernet interface
}

VlcbSpectrumModuleTypes = {
  # 
  # Spectrum Engineering Animated Modeller module types
  # 
  1 : "AMCTRLR", # Animation controller (firmware derived from cancmd)
  2 : "DUALCAB", # Dual cab based on cancab
}

VlcbSysPixieModuleTypes = {
  # 
  # SysPixie Module types (Konrad Orlowski)
  # 
  1 : "CANPMSense", # Motorised point motor driver with current sense
}

VlcbOpCodes = {
  # 
  # 
  # VLCB opcodes list
  # 
  # Packets with no data bytes
  # 
  0x00 : "ACK", # General ack
  0x01 : "NAK", # General nak
  0x02 : "HLT", # Bus Halt
  0x03 : "BON", # Bus on
  0x04 : "TOF", # Track off
  0x05 : "TON", # Track on
  0x06 : "ESTOP", # Track stopped
  0x07 : "ARST", # System reset
  0x08 : "RTOF", # Request track off
  0x09 : "RTON", # Request track on
  0x0a : "RESTP", # Request emergency stop all
  0x0c : "RSTAT", # Request node status
  0x0d : "QNN", # Query nodes
  # 
  0x10 : "RQNP", # Read node parameters
  0x11 : "RQMN", # Request name of module type
  # 
  # Packets with 1 data byte
  # 
  0x21 : "KLOC", # Release engine by handle
  0x22 : "QLOC", # Query engine by handle
  0x23 : "DKEEP", # Keep alive for cab
  # 
  0x30 : "DBG1", # Debug message with 1 status byte
  0x3F : "EXTC", # Extended opcode
  # 
  # Packets with 2 data bytes
  # 
  0x40 : "RLOC", # Request session for loco
  0x41 : "QCON", # Query consist
  0x42 : "SNN", # Set node number
  0X43 : "ALOC", # Allocate loco (used to allocate to a shuttle in cancmd)
  # 
  0x44 : "STMOD", # Set Throttle mode
  0x45 : "PCON", # Consist loco
  0x46 : "KCON", # De-consist loco
  0x47 : "DSPD", # Loco speed/dir
  0x48 : "DFLG", # Set engine flags
  0x49 : "DFNON", # Loco function on
  0x4A : "DFNOF", # Loco function off
  0x4C : "SSTAT", # Service mode status
  0x4F : "NNRSM", # Reset to manufacturer's defaults
  # 
  0x50 : "RQNN", # Request Node number in setup mode
  0x51 : "NNREL", # Node number release
  0x52 : "NNACK", # Node number acknowledge
  0x53 : "NNLRN", # Set learn mode
  0x54 : "NNULN", # Release learn mode
  0x55 : "NNCLR", # Clear all events
  0x56 : "NNEVN", # Read available event slots
  0x57 : "NERD", # Read all stored events
  0x58 : "RQEVN", # Read number of stored events
  0x59 : "WRACK", # Write acknowledge
  0x5A : "RQDAT", # Request node data event
  0x5B : "RQDDS", # Request short data frame
  0x5C : "BOOT", # Put node into boot mode
  0x5D : "ENUM", # Force can_id self enumeration
  0x5E : "NNRST", # Reset node (as in restart)
  0x5F : "EXTC1", # Extended opcode with 1 data byte
  # 
  # Packets with 3 data bytes
  # 
  0x60 : "DFUN", # Set engine functions
  0x61 : "GLOC", # Get loco (with support for steal/share)
  0x63 : "ERR", # Command station error
  0x6F : "CMDERR", # Errors from nodes during config
  # 
  0x70 : "EVNLF", # Event slots left response
  0x71 : "NVRD", # Request read of node variable
  0x72 : "NENRD", # Request read stored event by index
  0x73 : "RQNPN", # Request read module parameters
  0x74 : "NUMEV", # Number of events stored response
  0x75 : "CANID", # Set canid
  0x76 : "MODE", # Set mode
  0x78 : "RQSD", # Request service discovery
  0x7F : "EXTC2", # Extended opcode with 2 data bytes
  # 
  # Packets with 4 data bytes
  # 
  0x80 : "RDCC3", # 3 byte DCC packet
  0x82 : "WCVO", # Write CV byte Ops mode by handle
  0x83 : "WCVB", # Write CV bit Ops mode by handle
  0x84 : "QCVS", # Read CV
  0x85 : "PCVS", # Report CV
  0x87 : "RDGN", # Request diagnostics
  0x8E : "NVSETRD", # Set NV with Read
  # 
  0x90 : "ACON", # on event
  0x91 : "ACOF", # off event
  0x92 : "AREQ", # Accessory Request event
  0x93 : "ARON", # Accessory response event on
  0x94 : "AROF", # Accessory response event off
  0x95 : "EVULN", # Unlearn event
  0x96 : "NVSET", # Set a node variable
  0x97 : "NVANS", # Node variable value response
  0x98 : "ASON", # Short event on
  0x99 : "ASOF", # Short event off
  0x9A : "ASRQ", # Short Request event
  0x9B : "PARAN", # Single node parameter response
  0x9C : "REVAL", # Request read of event variable
  0x9D : "ARSON", # Accessory short response on event
  0x9E : "ARSOF", # Accessory short response off event
  0x9F : "EXTC3", # Extended opcode with 3 data bytes
  # 
  # Packets with 5 data bytes
  # 
  0xA0 : "RDCC4", # 4 byte DCC packet
  0xA2 : "WCVS", # Write CV service mode
  0xAB : "HEARTB", # Heartbeat
  0xAC : "SD", # Service discovery response
  0xAF : "GRSP", # General response
  # 
  0xB0 : "ACON1", # On event with one data byte
  0xB1 : "ACOF1", # Off event with one data byte
  0xB2 : "REQEV", # Read event variable in learn mode
  0xB3 : "ARON1", # Accessory on response (1 data byte)
  0xB4 : "AROF1", # Accessory off response (1 data byte)
  0xB5 : "NEVAL", # Event variable by index read response
  0xB6 : "PNN", # Response to QNN
  0xB8 : "ASON1", # Accessory short on with 1 data byte
  0xB9 : "ASOF1", # Accessory short off with 1 data byte
  0xBD : "ARSON1", # Short response event on with one data byte
  0xBE : "ARSOF1", # Short response event off with one data byte
  0xBF : "EXTC4", # Extended opcode with 4 data bytes
  # 
  # Packets with 6 data bytes
  # 
  0xC0 : "RDCC5", # 5 byte DCC packet
  0xC1 : "WCVOA", # Write CV ops mode by address
  0xC2 : "CABDAT", # Cab data (cab signalling)
  0xC7 : "DGN", # Diagnostics
  0xCF : "FCLK", # Fast clock
  # 
  0xD0 : "ACON2", # On event with two data bytes
  0xD1 : "ACOF2", # Off event with two data bytes
  0xd2 : "EVLRN", # Teach event
  0xd3 : "EVANS", # Event variable read response in learn mode
  0xD4 : "ARON2", # Accessory on response
  0xD5 : "AROF2", # Accessory off response
  0xD8 : "ASON2", # Accessory short on with 2 data bytes
  0xD9 : "ASOF2", # Accessory short off with 2 data bytes
  0xDD : "ARSON2", # Short response event on with two data bytes
  0xDE : "ARSOF2", # Short response event off with two data bytes
  0xDF : "EXTC5", # Extended opcode with 5 data bytes
  # 
  # Packets with 7 data bytes
  # 
  0xE0 : "RDCC6", # 6 byte DCC packets
  0xE1 : "PLOC", # Loco session report
  0xE2 : "NAME", # Module name response
  0xE3 : "STAT", # Command station status report
  0xE6 : "ENACK", # Event Acknowledge
  0xE7 : "ESD", # Extended service discovery
  0xE9 : "DTXC", # Long message packet
  0xEF : "PARAMS", # Node parameters response
  # 
  0xF0 : "ACON3", # On event with 3 data bytes
  0xF1 : "ACOF3", # Off event with 3 data bytes
  0xF2 : "ENRSP", # Read node events response
  0xF3 : "ARON3", # Accessory on response
  0xF4 : "AROF3", # Accessory off response
  0xF5 : "EVLRNI", # Teach event using event indexing
  0xF6 : "ACDAT", # Accessory data event: 5 bytes of node data (eg: RFID)
  0xF7 : "ARDAT", # Accessory data response
  0xF8 : "ASON3", # Accessory short on with 3 data bytes
  0xF9 : "ASOF3", # Accessory short off with 3 data bytes
  0xFA : "DDES", # Short data frame aka device data event (device id plus 5 data bytes)
  0xFB : "DDRS", # Short data frame response aka device data response
  0xFC : "DDWS", # Device Data Write Short
  0xFD : "ARSON3", # Short response event on with 3 data bytes
  0xFE : "ARSOF3", # Short response event off with 3 data bytes
  0xFF : "EXTC6", # Extended opcode with 6 data byes
  # 
  # Opcodes that are proposed and/or agreed but not yet in the current published specification
  # 
  0xA4 : "VCVS", # Verify CV service mode - used for CV read hints
}

VlcbStmodModes = {
  # 
  # 
  # Modes for STMOD
  # 
  3 : "SPD_MASK",
  0 : "SPD_128",
  1 : "SPD_14",
  2 : "SPD_28I",
  3 : "SPD_28",
}

VlcbErrs = {
  # 
  # Error codes for OPC_ERR
  # 
  1 : "LOCO_STACK_FULL",
  2 : "LOCO_ADDR_TAKEN",
  3 : "SESSION_NOT_PRESENT",
  4 : "CONSIST_EMPTY",
  5 : "LOCO_NOT_FOUND",
  6 : "CMD_RX_BUF_OFLOW",
  7 : "INVALID_REQUEST",
  8 : "SESSION_CANCELLED",
}

VlcbSStats = {
  # 
  # Status codes for OPC_SSTAT
  # 
  1 : "NO_ACK",
  2 : "OVLD",
  3 : "WR_ACK",
  4 : "BUSY",
  5 : "CV_ERROR",
}

VlcbCmdErrs = {
  # 
  # Error codes for OPC_CMDERR
  # 
  1 : "INV_CMD", # Invalid command
  2 : "NOT_LRN", # Not in learn mode
  3 : "NOT_SETUP", # Not in setup mode
  4 : "TOO_MANY_EVENTS", # Too many events
  5 : "NO_EV", # No EV
  6 : "INV_EV_IDX", # Invalid EV index
  7 : "INVALID_EVENT", # Invalid event
  8 : "INV_EN_IDX", # now reserved
  9 : "INV_PARAM_IDX", # Invalid param index
  10 : "INV_NV_IDX", # Invalid NV index
  11 : "INV_EV_VALUE", # Invalid EV value
  12 : "INV_NV_VALUE", # Invalid NV value
  # 
  # Additional error codes proposed and/or agreed but not yet in the current published specification
  # 
  13 : "LRN_OTHER", # Sent when module in learn mode sees NNLRN for different module (also exits learn mode) 
  # 
}

VlcbGrspCodes = {
  # 
  # GRSP codes
  # 
  0 : "OK", # Success
  254 : "UNKNOWN_NVM_TYPE", # Unknown non volatile memory type
  253 : "INVALID_DIAGNOSTIC", # Invalid diagnostic
  252 : "INVALID_SERVICE", # Invalid service
  251 : "INVALID_COMMAND_PARAMETER", # Invalid parameter in command
  250 : "INVALID_MODE", # Invalid Mode
}

VlcbCabSigAspect0 = {
  # 
  # Sub opcodes for OPC_CABDAT
  # 
  1 : "CABSIG",
}

VlcbCabSigAspect1 = {
  # 
  # Aspect codes for CDAT_CABSIG
  # 
  # First aspect byte
  # 
  0 : "DANGER",
  1 : "CAUTION",
  2 : "PRELIM_CAUTION",
  3 : "PROCEED",
  4 : "CALLON", # Set bit 2 for call-on - main aspect will usually be at danger
  8 : "THEATRE", # Set bit 3 to 0 for upper nibble is feather lcoation, set 1 for upper nibble is theatre code
}

VlcbCabSigAspect2 = {
  # 
  # Aspect codes for CDAT_CABSIG
  # 
  # Second Aspect byte
  # 
  0 : "LIT", # Set bit 0 to indicate lit
  1 : "LUNAR", # Set bit 1 for lunar indication
  # 
  # Remaining bits in second aspect byte yet to be defined - can be used for other signalling systems
}

VlcbServiceTypes = {
  # 
  # VLCB Service Types
  # 
  0 : "ID_NONE", # Not a real service. Will not be shown in list of services requested by RQSD.
  1 : "ID_MNS", # The minimum node service. All modules must implement this.
  2 : "ID_NV", # The NV service.
  3 : "ID_CAN", # CAN service. Deals with CANID enumeration.
  4 : "ID_OLD_TEACH", # Old (CBUS) event teaching service.
  5 : "ID_PRODUCER", # Event producer service.
  6 : "ID_CONSUMER", # Event comsumer service.
  7 : "ID_TEACH", # New event teaching service.
  8 : "ID_CONSUME_OWN_EVENTS", # Consume own events service.
  9 : "ID_EVENTACK", # Event acknowledge service. Useful for debugging event configuration.
  10 : "ID_BOOT", # FCU/PIC bootloader service.
  17 : "ID_STREAMING", # Streaming (Long Messages) service.
  # Use IDs 240 and higher for services in development that do not yet have a service specification.
}

VlcbParams = {
  # 
  # 
  # Parameter index numbers (readable by OPC_RQNPN, returned in OPC_PARAN)
  # Index numbers count from 1, subtract 1 for offset into parameter block
  # Note that RQNPN with index 0 returns the parameter count
  # 
  0 : "NUM", # Number of parameters
  1 : "MANU", # Manufacturer id
  2 : "MINVER", # Minor version letter
  3 : "MTYP", # Module type code
  4 : "EVTNUM", # Number of events supported
  5 : "EVNUM", # Event variables per event
  6 : "NVNUM", # Number of Node variables
  7 : "MAJVER", # Major version number
  8 : "FLAGS", # Node flags
  9 : "CPUID", # Processor type
  10 : "BUSTYPE", # Bus type
  11 : "LOAD", # load address, 4 bytes
  15 : "CPUMID", # CPU manufacturer's id as read from the chip config space, 4 bytes (note - read from cpu at runtime, so not included in checksum)
  19 : "CPUMAN", # CPU manufacturer code
  20 : "BETA", # Beta revision (numeric), or 0 if release
}

VlcbParamOffsetsPic = {
  # 
  # Offsets to other values stored at the top of the parameter block.
  # These are not returned by opcode PARAN, but are present in the hex
  # file for FCU.
  # 
  0x18 : "COUNT", # Number of parameters implemented
  0x1A : "NAME", # 4 byte Address of Module type name, up to 8 characters null terminated
  0x1E : "CKSUM", # Checksum word at end of parameters
}

VlcbParamFlags = {
  # 
  # Flags in PAR_FLAGS
  # 
  0 : "NOEVENTS", # Module doesn't support events
  1 : "CONSUMER", # Module is a consumer of events
  2 : "PRODUCER", # Module is a producer of events
  3 : "COMBI", # Module is both a consumer and producer of events
  4 : "FLiM", # Module is in FLiM (CBUS)
  4 : "NORMAL", # Module is in Normal mode (VLCB)
  8 : "BOOT", # Module supports the FCU bootloader protocol
  16 : "COE", # Module can consume its own events
  32 : "LRN", # Module is in learn mode
  64 : "VLCB", # Module is VLCB compatible
}

VlcbModeParams = {
  # 
  # Parameters to the MODE op-code
  # 
  # Exclusive modes
  0xFF : "UNINITIALISED", # Uninitialised / factory settings
  0 : "SETUP", # Set up mode
  1 : "NORMAL", # Normal operation mode
  # Event Teaching Service modes
  0x08 : "LEARN_ON", # Turn on learn mode
  0x09 : "LEARN_OFF", # Turn off learn mode
  # Event Acknowledgment Service modes
  0x0A : "EVENT_ACK_ON", # Turn on event acknowledgements
  0x0B : "EVENT_ACK_OFF", # Turn off event acknowledgements
  # Minimum Node Service modes
  0x0C : "HEARTBEAT_ON", # Turn on heartbeat
  0x0D : "HEARTBEAT_OFF", # Turn off heartbeat
  # Boot modes
  0x0E : "BOOT", # PIC Boot loader mode
}

VlcbBusTypes = {
  # 
  # BUS type that module is connected to
  # 
  1 : "CAN",
  2 : "ETH",
  3 : "MIWI",
  4 : "USB",
}

VlcbProcessorManufacturers = {
  # 
  # Processor manufacturer codes
  # 
  1 : "MICROCHIP",
  2 : "ATMEL",
  3 : "ARM",
}

VlcbMicrochipProcessors = {
  # 
  # Microchip Processor type codes (identifies to FCU for bootload compatibility)
  # 
  1 : "P18F2480",
  2 : "P18F4480",
  3 : "P18F2580",
  4 : "P18F4580",
  5 : "P18F2585",
  6 : "P18F4585",
  7 : "P18F2680",
  8 : "P18F4680",
  9 : "P18F2682",
  10 : "P18F4682",
  11 : "P18F2685",
  12 : "P18F4685",
  # 
  13 : "P18F25K80",
  14 : "P18F45K80",
  15 : "P18F26K80",
  16 : "P18F46K80",
  17 : "P18F65K80",
  18 : "P18F66K80",
  19 : "P18F25K83",
  20 : "P18F26K83",
  21 : "P18F27Q84",
  22 : "P18F47Q84",
  23 : "P18F27Q83",
  25 : "P18F14K22",
  # 
  30 : "P32MX534F064",
  31 : "P32MX564F064",
  32 : "P32MX564F128",
  33 : "P32MX575F256",
  34 : "P32MX575F512",
  35 : "P32MX764F128",
  36 : "P32MX775F256",
  37 : "P32MX775F512",
  38 : "P32MX795F512",
}

VlcbArmProcessors = {
  # 
  # ARM Processor type codes (identifies to FCU for bootload compatibility)
  # 
  1 : "S", # As used in Raspberry Pi
  2 : "A7", # As Used in Raspberry Pi 2
  3 : "A53", # As used in Raspberry Pi 3
}

VlcbCanHardware = {
  # 
  # CAN engine type codes
  # 
  0x00 : "HW_NOT_SPECIFIED", # Not set
  0x01 : "HW_PIC_ECAN", # MICROCHIP PIC ECAN
  0x02 : "HW_PIC_CAN_2_0", # MICROCHIP PIC CAN 2.0
  0x03 : "HW_PIC_CAN_FD", # MICROCHIP PIC CAN FD
  0x04 : "HW_MCP2515", # MICROCHIP 2515
  0x05 : "HW_MCP2518", # MICROCHIP 2518
  0x06 : "HW_ESP32_TWAI", # ESP32 Two Wire Automotive Interface
  0x07 : "HW_SAM3X8E", # Atmel Cortex M3
  0x08 : "HW_PICO_PIO", # Raspberry Pico based on RP2040 using PIO
}

VlcbProducerEvUsage = {
  # 
  # Producer service EV usage
  # 
  0x00 : "EV_NOT_SPECIFIED", # Not specified
  0x01 : "EV_HAPPENING", # Happenings
  0x02 : "EV_SLOTS", # Slots
}

VlcbConsumerEvUsage = {
  # 
  # Consumer service EV usage
  # 
  0x00 : "EV_NOT_SPECIFIED", # Not specified
  0x01 : "EV_ACTIONS", # Actions
  0x02 : "EV_SLOTS", # Slots
}

